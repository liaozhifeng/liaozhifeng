
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>离散数学复习 - xinyu</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="不断前进才能做更多喜欢的事,图论

零图：\(E = ∅\)，即只有顶点，没有边的图。
平凡图：只有一个顶点（也称\(1\)阶图）的零图。
悬挂顶点：度数为\(1\)的顶点；悬挂边：与悬挂顶点关联的边。
在无向图中，,"> 
    <meta name="author" content="xinyu"> 
    <link rel="alternative" href="atom.xml" title="xinyu" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">xinyu</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://liaozhifeng.gitee.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">离散数学复习</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">离散数学复习</h1>
        <div class="stuff">
            <span>一月 22, 2021</span>
            

        </div>
        <div class="content markdown">
            <h3 id="图论">图论</h3>
<ul>
<li><p>零图：<span class="math inline">\(E = ∅\)</span>，即只有顶点，没有边的图。</p></li>
<li><p>平凡图：只有一个顶点（也称<span class="math inline">\(1\)</span>阶图）的零图。</p></li>
<li><p>悬挂顶点：度数为<span class="math inline">\(1\)</span>的顶点；悬挂边：与悬挂顶点关联的边。</p></li>
<li><p>在无向图中，图的最大度：<span class="math inline">\(∆(G)={d(v)|v\in V}\)</span>，其中<span class="math inline">\(V\)</span>表示顶点集，<span class="math inline">\(d(v)\)</span>表示顶点的度数，记住用<span class="math inline">\(\Delta(G)\)</span>去表示最大度；同理图的最小度的定义易得，注意的是我们用<span class="math inline">\(\delta(G)\)</span>表示图的最小度。另外无向图用<span class="math inline">\((v_n,v_m)\)</span>表示边。</p></li>
<li><p>在有向图中，<span class="math inline">\(v\)</span>的入度<span class="math inline">\(d^+(v)\)</span>，<span class="math inline">\(v\)</span>的出度<span class="math inline">\(d^-(v)\)</span>，<span class="math inline">\(v\)</span>的度数<span class="math inline">\(d(v) = d^+(v)+d^-(v)\)</span>，同时有向图还定义了出度、入度的最大度和最小度。有向图用<span class="math inline">\(\langle v_n,v_m \rangle\)</span>表示边。</p></li>
<li><p>握手定理：图的所有顶点的度数之和等于边数的<span class="math inline">\(2\)</span>倍，因为每条边都提供<span class="math inline">\(2\)</span>度，所以度数之和一定是偶数。</p></li>
<li><p>度数列：<span class="math inline">\(V=\{v_1,v_2,...v_n\}\)</span>，<span class="math inline">\(G\)</span>的度数列：<span class="math inline">\(d(v_1),d(v_2),...,d(v_n)\)</span>。</p></li>
<li><p>简单图：既无平行边也无环的图称为简单图。其中平行边的条数称为重数。</p></li>
<li><p>完全图和正则图：无向完全图，记作<span class="math inline">\(K_n\)</span>，边数为<span class="math inline">\(n(n-1)/2\)</span>，有向完全图，边数为<span class="math inline">\(n(n-1)\)</span>；<span class="math inline">\(k-\)</span>正则图：每个顶点的度数均为<span class="math inline">\(k\)</span>的无向简单图。</p></li>
<li><p>子图：生成子图：<span class="math inline">\(V&#39; = V\)</span>且<span class="math inline">\(G&#39;\subseteq G\)</span>；<span class="math inline">\(V&#39;\)</span>的导出子图，以两端点都在<span class="math inline">\(V&#39;\)</span>中所有的边集的子图，记作<span class="math inline">\(G[V&#39;]\)</span>；<span class="math inline">\(E&#39;\)</span>的导出子图：以<span class="math inline">\(E&#39;\)</span>所以关联的顶点为顶点集的子图，记作<span class="math inline">\(G[E&#39;]\)</span>。</p></li>
<li><p>通路：<span class="math inline">\(Γ = v_0e_1v_1e_2...e_lv_l\)</span> ，称<span class="math inline">\(Γ\)</span>为<span class="math inline">\(v_0\)</span>到<span class="math inline">\(v_l\)</span>的通路，<span class="math inline">\(l\)</span>为通路的长度，若<span class="math inline">\(v_0=v_l\)</span>则称$Γ <span class="math inline">\(为回路。若通路（回路）中所有顶点（对于回路，\)</span>v_0=v_l$）各异，称此通路<strong>初级通路（回路）</strong>；若通路中所有的边各异，则称为简单通路。初级通路是简单通路，反之不然。</p></li>
<li><p><span class="math inline">\(Γ\)</span>的表示方法 ：用顶点和边交替序列、用边序列、简单图中用顶点序列。</p></li>
<li><p>连通分支：设<span class="math inline">\(R\)</span>是<span class="math inline">\(G\)</span>中顶点之间的连通关系，按<span class="math inline">\(R\)</span>可将<span class="math inline">\(V(G)\)</span>划分为<span class="math inline">\(k\)</span>个等价类，记作<span class="math inline">\(V_1,V_2,...,V_k\)</span>，由他们的导出子图<span class="math inline">\(G[V_1],G[V_2],...,G[V_k]\)</span>称为<span class="math inline">\(G\)</span>的连通分支。令<span class="math inline">\(p(G)=k\)</span>表示<span class="math inline">\(G\)</span>的连通分支数为<span class="math inline">\(k\)</span>。</p></li>
<li><p>点割集与边割集：若<span class="math inline">\(V&#39; \subset V\)</span>，<span class="math inline">\(p(V-V&#39;)&gt;p(V)\)</span>，且<span class="math inline">\(\forall V&#39;&#39; \subset V\)</span>，<span class="math inline">\(p(V-V&#39;&#39;) = V\)</span>，则称<span class="math inline">\(V&#39;\)</span>为<span class="math inline">\(G\)</span>的点割集，若点割集只有一个点，则称此顶点为割点；同理可以得到边割集的定义，若边割集只有一条边则称此边为割边或桥。</p></li>
<li><p>点连通度和边连通度：记<span class="math inline">\(min\{|V&#39;| \space | V&#39;\)</span>是<span class="math inline">\(G\)</span>的点割集<span class="math inline">\(\}=\kappa(G)\)</span>，称为<span class="math inline">\(G\)</span>的点连通度；记<span class="math inline">\(min\{|E&#39;| \space|E&#39;\)</span>是<span class="math inline">\(G\)</span>的边割集<span class="math inline">\(\} = \lambda(G)\)</span>，称为<span class="math inline">\(G\)</span>的边连通度。对于任意的无向图有<span class="math inline">\(\kappa(G)\leq \lambda(G)\leq \delta(G)\)</span> 。</p></li>
<li><p>二部图判别定理：无向图<span class="math inline">\(G=\langle V,E\rangle\)</span>是二部图当且仅当<span class="math inline">\(G\)</span>中无奇数长度的回路，记作<span class="math inline">\(\langle V_1,V_2,E\rangle\)</span>。二部图还有一个非常重要的匹配问题，匹配就是<span class="math inline">\(E&#39; \subseteq E\)</span>，且<span class="math inline">\(E&#39;\)</span>中的边互补相邻，注意极大匹配，最大匹配，完备匹配，完美匹配等问题。</p>
<a id="more"></a></li>
<li><p>完备匹配判定定理$(|V_1||V_2|) <span class="math inline">\(：(Hall定理)，存在\)</span>V_1,V_2<span class="math inline">\(的完备匹配当且仅当\)</span>V_1<span class="math inline">\(中任意\)</span>k(1k|V_1|)<span class="math inline">\(个顶点至少与\)</span>V_2<span class="math inline">\(中\)</span>k<span class="math inline">\(个顶点相邻；（t条件）：如果存在正整数\)</span>t<span class="math inline">\(，使得\)</span>V_1<span class="math inline">\(中每个顶点至少关联\)</span>t<span class="math inline">\(条边，而\)</span>V_2<span class="math inline">\(中的顶点至多关联\)</span>t<span class="math inline">\(条边，则\)</span>G<span class="math inline">\(中存在\)</span>V_1<span class="math inline">\(到\)</span>V_2$的完备匹配。</p></li>
<li><p>无向图关联矩阵：<span class="math inline">\(m_{ij}\)</span>为<span class="math inline">\(v_i\)</span>与<span class="math inline">\(e_j\)</span>的关联次数；无环有向图关联矩阵：<span class="math inline">\(m_{ij}=-1,0,1\)</span>，<span class="math inline">\(1\)</span>代表是起点，<span class="math inline">\(-1\)</span>代表是终点；关联矩阵记为<span class="math inline">\(M\)</span>。 有向图的邻接矩阵：<span class="math inline">\(a_{i,j}\)</span>为以<span class="math inline">\(v_i\)</span>为起点，<span class="math inline">\(v_j\)</span>为终点的边的条数，记为<span class="math inline">\(A\)</span>。<span class="math inline">\(A^l\)</span>中元素表示长度为<span class="math inline">\(l\)</span>的边的条数。 可达矩阵：<span class="math inline">\(p_{ij} = 0,1\)</span>，<span class="math inline">\(1\)</span>表示可达。</p></li>
<li><p>欧拉通路：经过所有顶点且每条边恰好且经过一次的通路。无向图具有欧拉回路当且仅当<span class="math inline">\(G\)</span>是连通的且无奇度顶点，无向图具有欧拉通路当且仅当图是连通的且只有两个奇度顶点。有向图具有欧拉回路当且仅当<span class="math inline">\(G\)</span>是连通的且每个顶点的出度等于入度，具有欧拉通路当且图中有一个顶点<span class="math inline">\(d^--d^+ = 1\)</span>，有一个顶点<span class="math inline">\(d^+-d^-=1\)</span>，其他顶点的出度等于入度。</p></li>
<li><p>哈密顿通路：经过图中所有顶点一次且仅一次的通路。 必要条件：若无向图是哈密顿图，则对于<span class="math inline">\(V\)</span>的任意非空真子集<span class="math inline">\(V&#39;\)</span>，均有<span class="math inline">\(p(V-V&#39;)&lt;|V&#39;|\)</span>,推论，有割点的图不是哈密顿图。 充分条件：若<span class="math inline">\(G\)</span>是<span class="math inline">\(n\)</span>阶无向图，<span class="math inline">\(d(u)+d(v)\geq n-1\)</span>，<span class="math inline">\(u,v\)</span>为<span class="math inline">\(G\)</span>中任意不相邻点，则<span class="math inline">\(G\)</span>中存在哈密顿通路；若<span class="math inline">\(d(u)+d(v)\geq n\)</span>则<span class="math inline">\(G\)</span>中存在哈密顿回路。</p></li>
<li><p>基本回路系统：设<span class="math inline">\(T\)</span>是<span class="math inline">\(n\)</span>阶<span class="math inline">\(m\)</span>条边的无向连通图<span class="math inline">\(G\)</span>的一棵生成树，设<span class="math inline">\(e_1,e_2,...,e_{n-m+1}\)</span>为<span class="math inline">\(T\)</span>的弦，<span class="math inline">\(C_r(r=1,2,...,m-n+1)\)</span>为<span class="math inline">\(T\)</span>添加弦<span class="math inline">\(e_r\)</span>产生的<span class="math inline">\(G\)</span>中由弦<span class="math inline">\(e_r\)</span>和树枝构成的圈，称<span class="math inline">\(C_r\)</span>为<span class="math inline">\(G\)</span>的对应弦<span class="math inline">\(e_r\)</span>基本回路或基本图，称<span class="math inline">\(\{C_1.C_2,...,C_{m-n+1}\}\)</span>为<span class="math inline">\(G\)</span>对应<span class="math inline">\(T\)</span>的基本回路系统，称<span class="math inline">\(m-n+1\)</span>为<span class="math inline">\(G\)</span>的圈秩，记作<span class="math inline">\(ξ(G)\)</span>。</p></li>
<li><p>基本割集系统：设<span class="math inline">\(T\)</span>是<span class="math inline">\(n\)</span>阶的无向连通图<span class="math inline">\(G\)</span>的一棵生成树，设<span class="math inline">\(e_1,e_2,...,e_{n-1}\)</span>为<span class="math inline">\(T\)</span>的树枝，<span class="math inline">\(S_i(i=1,2,..,n-1)\)</span>为由树枝<span class="math inline">\(e_i\)</span>和弦构成的割集。称<span class="math inline">\(\{S_1,S_2,...,S_{n-1}\}\)</span>为<span class="math inline">\(G\)</span>对应<span class="math inline">\(T\)</span>的基本割集系统，称<span class="math inline">\(n-1\)</span>为<span class="math inline">\(G\)</span>的割集秩，记作<span class="math inline">\(η(G)\)</span>。</p></li>
<li><p>平面图与平面嵌入：如果能将图<span class="math inline">\(G\)</span>中除顶点外边不相交地画在平面上，则称<span class="math inline">\(G\)</span>是平面图，由这个图画出的无边相交的图称为<span class="math inline">\(G\)</span>的平面嵌入，没有平面嵌入的图称为非平面图。</p></li>
<li><p>平面图的一些概念：无限面，用<span class="math inline">\(R_0\)</span>表示，有限面，用<span class="math inline">\(R_1, R_2, ..., R_k\)</span>表示，面<span class="math inline">\(R_i\)</span>的次数，<span class="math inline">\(R\)</span>边界的长度，用<span class="math inline">\(deg(R_i)\)</span>表示。 平面图各面的次数之和等于边数的<span class="math inline">\(2\)</span>倍，一条边或者是<span class="math inline">\(2\)</span>个面的公共边界，或者在一个面中出现两次，特别要注意的是这种出现两次的情况，这种边应该只会在无限面中出现，所以在写无限面的边界时也应该注意，这条边要写两次。</p></li>
<li><p>极大平面图：在简单平面中任意不相邻的顶点之间加一条新边所得的图为非平面图。极大平面是连通的，且设<span class="math inline">\(G\)</span>为<span class="math inline">\(n(\geq3)\)</span>阶简单平面图，<span class="math inline">\(G\)</span>为极大平面图的充分必要条件是，<span class="math inline">\(G\)</span>的每个面次数均为<span class="math inline">\(3\)</span>。</p></li>
<li><p>欧拉公式：设<span class="math inline">\(G\)</span>为<span class="math inline">\(n\)</span>阶<span class="math inline">\(m\)</span>条边<span class="math inline">\(r\)</span>个面的连通平面图，则<span class="math inline">\(n-m+r=2\)</span>。 欧拉公式的推论：设平面<span class="math inline">\(G\)</span>中有<span class="math inline">\(p(p\geq 2)\)</span>连通分支，则<span class="math inline">\(n-m+r=p+1\)</span></p></li>
<li><p>同胚与收缩：<span class="math inline">\(G_1\)</span>与<span class="math inline">\(G_2\)</span>同构，或经过反复插入或消去<span class="math inline">\(2\)</span>度顶点后，称为同胚。收缩边称为收缩。 库拉图斯基定理：一个图是平面图当且仅当它既不包含与<span class="math inline">\(K_5\)</span>同胚的<strong>子图</strong>，也不含与<span class="math inline">\(K_{3,3}\)</span>同胚的子图，一个图是平面图当且仅当它既无可收缩为<span class="math inline">\(K_5\)</span>的子图，也无可收缩为<span class="math inline">\(K_{3,3}\)</span>的子图。</p></li>
<li><p>对偶图的性质：设<span class="math inline">\(G^*\)</span>是连通图<span class="math inline">\(G\)</span>的对偶图，<span class="math inline">\(n^*,m^*,r^*\)</span>和<span class="math inline">\(n,m,r\)</span>分别为<span class="math inline">\(G^*,G\)</span>的顶点数，边数，面数，有<span class="math inline">\(n^*=r,m*=m,r^*=n\)</span>，设<span class="math inline">\(G^*\)</span>的顶点<span class="math inline">\(v^*_i\)</span>位于<span class="math inline">\(G\)</span>的面<span class="math inline">\(R_i\)</span>中，则<span class="math inline">\(d(v^*_i)=deg(R_i)\)</span>。</p></li>
</ul>
<h3 id="代数结构">代数结构</h3>
<ul>
<li>积代数：设<span class="math inline">\(V_1 = \langle S_1, \circ \rangle, V_2 =\langle S_2, *\rangle\)</span>，<span class="math inline">\(V_1\)</span>与<span class="math inline">\(V_2\)</span>的积代数<span class="math inline">\(V=\langle S_1\times S_2,\cdot\rangle\)</span>，<span class="math inline">\(\langle x_1, y_1 \rangle,\langle x_2,y_2\rangle \in S_1\times S_2\)</span>。<span class="math inline">\(\langle x_1, y_1 \rangle\cdot \langle x_2,y_2\rangle\)</span> <span class="math inline">\(=&lt;x_1\circ x_2, y_1*y_2&gt;\)</span>。</li>
<li>设<span class="math inline">\(G=&lt;a&gt;\)</span>是<span class="math inline">\(n\)</span>阶循环群，则对<span class="math inline">\(n\)</span>的每个正因子<span class="math inline">\(d\)</span>，<span class="math inline">\(G\)</span>恰好有一个<span class="math inline">\(d\)</span>阶的子群。</li>
<li>设<span class="math inline">\(G=&lt;a&gt;\)</span>是循环群，若<span class="math inline">\(G\)</span>是无限循环群，则<span class="math inline">\(G\)</span>只有两个生成元，即<span class="math inline">\(a\)</span>和<span class="math inline">\(a^{-1}\)</span>。若<span class="math inline">\(G\)</span>是<span class="math inline">\(n\)</span>阶循环群，则<span class="math inline">\(G\)</span>有<span class="math inline">\(\phi(n)\)</span>个生成元，对于任意小于<span class="math inline">\(n\)</span>且与<span class="math inline">\(n\)</span>互素的自然数<span class="math inline">\(r\)</span>，<span class="math inline">\(a^r\)</span>是<span class="math inline">\(G\)</span>的生成元。</li>
<li>子环判别定理：设<span class="math inline">\(R\)</span>是环，<span class="math inline">\(S\)</span>是<span class="math inline">\(R\)</span>得非空子集，若<span class="math inline">\(\forall a, b \in S\)</span>，<span class="math inline">\(a-b\in S\)</span>且<span class="math inline">\(\forall a,b \in S，ab\in S\)</span>，则<span class="math inline">\(S\)</span>是<span class="math inline">\(R\)</span>的子环。</li>
<li>如果<span class="math inline">\(R\)</span>既是交换环、含幺环、无零因子环，则称<span class="math inline">\(R\)</span>是整环。</li>
<li>域：若<span class="math inline">\(R\)</span>是整环，则对<span class="math inline">\(R\)</span>中的每个元素(<span class="math inline">\(\{0\}\)</span>除外)，都有逆元，则称<span class="math inline">\(R\)</span>是域。</li>
<li>格的定义：利用偏序集<span class="math inline">\(\langle S, \preccurlyeq \rangle\)</span>，如果<span class="math inline">\(\forall x, y \in S, \{x,y\}\)</span>都有最小上界和最大下界，则称<span class="math inline">\(S\)</span>关于偏序<span class="math inline">\(\preccurlyeq\)</span>做出一个格。<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>有<span class="math inline">\(\vee, \wedge\)</span>两个运算，其中<span class="math inline">\(\vee\)</span>表示最小上界，<span class="math inline">\(\wedge\)</span>表示最大下届。其中运算<span class="math inline">\(\vee, \wedge\)</span>还要满足交换律，结合律，幂等律，吸收律<span class="math inline">\(a(a\vee b) = a,a(a\wedge b)=a\)</span>。</li>
<li>格的等价定义：设<span class="math inline">\(\langle L,*,\cdot \rangle\)</span>是具有两个二元运算的代数系统，如果<span class="math inline">\(*,\cdot\)</span>满足交换律，结合律，幂等律，吸收率，则称<span class="math inline">\(\langle L,*,\cdot \rangle\)</span>是格。</li>
<li>判断一个偏序集是否构成格：可以判断每两个元素的最小上界跟最大下界是否唯一，如果不唯一则不构成格。</li>
<li>分配格：<span class="math inline">\(L\)</span>是分配格当且仅当<span class="math inline">\(L\)</span>不含与砖石格或者五角格同构的子格。或者当且仅当<span class="math inline">\(\forall a,b,c \in L\)</span>有<span class="math inline">\((a\vee b = a\vee c 且a\wedge b=a\wedge c)\)</span><span class="math inline">\(\rightarrow (b=c)\)</span>。特别的小于<span class="math inline">\(5\)</span>元的格，链都是分配格。</li>
<li>设<span class="math inline">\(\langle L, \wedge,\vee,0,1\rangle\)</span>是有界格，<span class="math inline">\(a\in L\)</span>, 若存在<span class="math inline">\(b\in L\)</span>使得<span class="math inline">\(a\vee b =1\)</span>和<span class="math inline">\(a\wedge b=0\)</span>成立则称<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的补元。若<span class="math inline">\(L\)</span>是有界分配格，则若<span class="math inline">\(L\)</span>中的元素存在补元，则只存在唯一的补元。若<span class="math inline">\(L\)</span>中所有的元素都存在补元，则称<span class="math inline">\(L\)</span>为有补格。</li>
<li>如果一个格是有补分配格，则称它为布尔格或者布尔代数，记作<span class="math inline">\(\langle L, \wedge,\vee,0,1,&#39;\rangle\)</span>，任何有限布尔代数的元素的个数都是<span class="math inline">\(2^n\)</span>。有<span class="math inline">\((a&#39;)&#39;=a\)</span>，还有德摩根律。</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
